#********************************************************************************
#                                                                               *
#               *    **   *  *   *                           *                  *
#              * *  *  *  *  *  * *                          *                  *
#             ***** *  *  *  * *****  **  ***  *  *  ** ***  ***                *
#             *   * *  *  *  * *   * *  * *  * *  * *   *  * *  *               *
#             *   * *  *  *  * *   * *  * *  * *  *   * *  * *  *               *
#             *   *  ** *  **  *   *  *** ***   *** **  ***  *  *               *
#                                       * *             *                       *
#                                     **  *             *                       *
#                                                                               *
#********************************************************************************
#                                                                               *
#  This file is part of AQUAgpusph, a free CFD program based on SPH.            *
#  Copyright (C) 2012  Jose Luis Cercos Pita <jl.cercos@upm.es>                 *
#                                                                               *
#  AQUAgpusph is free software: you can redistribute it and/or modify           *
#  it under the terms of the GNU General Public License as published by         *
#  the Free Software Foundation, either version 3 of the License, or            *
#  (at your option) any later version.                                          *
#                                                                               *
#  AQUAgpusph is distributed in the hope that it will be useful,                *
#  but WITHOUT ANY WARRANTY; without even the implied warranty of               *
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                *
#  GNU General Public License for more details.                                 *
#                                                                               *
#  You should have received a copy of the GNU General Public License            *
#  along with AQUAgpusph.  If not, see <http://www.gnu.org/licenses/>.          *
#                                                                               *
#********************************************************************************

from numpy import *
from vec import *
from sys import stdout

def perform(faces, level, dr, refd, cs, gamma, g):
	""" Create solid particles
	@param faces Faces defined by 4 points and a normal
	@param level Fluid level
	@param dr Distance between particles
	@param refd Fluid density
	@param cs Sound speed
	@param gamma Batchelor's 67 compressibility factor
	@param g Gravity acceleration
	@return Boundary vertexes
	"""
	parts      = []
	prb        = cs*cs*refd/gamma
	percentage = 0
	idf        = 0
	stdout.write("%d%%..." % (percentage))
	stdout.flush()
	for face in faces:
		u0  = face[1] - face[0]
		u1  = face[2] - face[3]
		v0  = face[3] - face[0]
		v1  = face[2] - face[1]
		lu0 = length(u0)
		lu1 = length(u1)
		lv0 = length(v0)
		lv1 = length(v1)
		nu  = (int(lu0/dr) + int(lu1/dr))/2
		nv  = (int(lv0/dr) + int(lv1/dr))/2
		# Triangles area
		ld0 = sqrt(lu0*lu0 + lv0*lv0)
		ld1 = sqrt(lu1*lu1 + lv1*lv1)
		sp0 = 0.5*(lu0 + lv0 + ld0)
		sp1 = 0.5*(lu1 + lv1 + ld1)
		a0  = sqrt(sp0*(sp0 - lu0)*(sp0 - lv0)*(sp0 - ld0))
		a1  = sqrt(sp1*(sp1 - lu1)*(sp1 - lv1)*(sp1 - ld1))
		A   = a0 + a1
		# Accumulated particles area
		a   = 0.0
		for i in range(0,nu):
			for j in range(0,nv):
				# Get point
				ufact = (i+0.5)/nu
				v     = ufact*v1 + (1.0-ufact)*v0
				vfact = (j+0.5)/nv
				u     = vfact*u1 + (1.0-vfact)*u0
				point = face[0] + ufact*u0 + vfact*v
				# Get points around the computed one in u,v direction
				ufact = float(i)/nu
				v     = ufact*v1 + (1.0-ufact)*v0
				vfact = float(j+0.5)/nv
				u     = vfact*u1 + (1.0-vfact)*u0
				bound = face[0] + ufact*u0 + vfact*v
				dist  = 0.5*absolute(bound - point)
				ufact = float(i+1.0)/nu
				v     = ufact*v1 + (1.0-ufact)*v0
				vfact = float(j+0.5)/nv
				u     = vfact*u1 + (1.0-vfact)*u0
				bound = face[0] + ufact*u0 + vfact*v
				dist  = dist + 0.5*absolute(bound - point)
				ufact = float(i+0.5)/nu
				v     = ufact*v1 + (1.0-ufact)*v0
				vfact = float(j)/nv
				u     = vfact*u1 + (1.0-vfact)*u0
				bound = face[0] + ufact*u0 + vfact*v
				dist  = dist + 0.5*absolute(bound - point)
				ufact = float(i+0.5)/nu
				v     = ufact*v1 + (1.0-ufact)*v0
				vfact = float(j+1.0)/nv
				u     = vfact*u1 + (1.0-vfact)*u0
				bound = face[0] + ufact*u0 + vfact*v
				dist  = dist + 0.5*absolute(bound - point)
				# Compute area associated to this point
				area  = dist[0]*dist[0] + dist[1]*dist[1] + dist[2]*dist[2]
				a     = a + area
				# Compute density from hidrostatic
				if point[2] <= level:
					press = refd*g*(level-point[2])
					dens  = pow( press/prb + 1.0, 1.0/gamma )*refd
				else:
					dens  = refd
				# Append particle
				parts.append([point,face[4],area,dens,cs])
		# Correct the area to fit to the real wall area
		fact = A / a
		for i in range(0,nu):
			for j in range(0,nv):
				parts[i*nv + j - nu*nv][2] = fact*parts[i*nv + j - nu*nv][2]
		idf   = idf + 1
		done  = min(idf*100 / len(faces), 100)
		if done != precentage:
			percentage = done
			stdout.write("%d%%..." % (percentage))
			stdout.flush()
	stdout.write("\n")
	return parts